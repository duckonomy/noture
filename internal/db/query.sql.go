// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAPIToken = `-- name: CreateAPIToken :one
INSERT INTO api_tokens (user_id, token_hash, name, expires_at)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, token_hash, name, last_used_at, expires_at, created_at
`

type CreateAPITokenParams struct {
	UserID    pgtype.UUID
	TokenHash string
	Name      string
	ExpiresAt pgtype.Timestamptz
}

func (q *Queries) CreateAPIToken(ctx context.Context, arg CreateAPITokenParams) (ApiToken, error) {
	row := q.db.QueryRow(ctx, createAPIToken,
		arg.UserID,
		arg.TokenHash,
		arg.Name,
		arg.ExpiresAt,
	)
	var i ApiToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.Name,
		&i.LastUsedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const createFileVersion = `-- name: CreateFileVersion :exec
INSERT INTO file_versions (file_id, version_number, content_hash, content)
VALUES ($1, $2, $3, $4)
`

type CreateFileVersionParams struct {
	FileID        pgtype.UUID
	VersionNumber int32
	ContentHash   string
	Content       []byte
}

func (q *Queries) CreateFileVersion(ctx context.Context, arg CreateFileVersionParams) error {
	_, err := q.db.Exec(ctx, createFileVersion,
		arg.FileID,
		arg.VersionNumber,
		arg.ContentHash,
		arg.Content,
	)
	return err
}

const createSyncOperation = `-- name: CreateSyncOperation :one
INSERT INTO sync_operations (workspace_id, file_id, operation_type, client_id, status)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, workspace_id, file_id, operation_type, client_id, status, error_message, created_at
`

type CreateSyncOperationParams struct {
	WorkspaceID   pgtype.UUID
	FileID        pgtype.UUID
	OperationType string
	ClientID      pgtype.Text
	Status        string
}

func (q *Queries) CreateSyncOperation(ctx context.Context, arg CreateSyncOperationParams) (SyncOperation, error) {
	row := q.db.QueryRow(ctx, createSyncOperation,
		arg.WorkspaceID,
		arg.FileID,
		arg.OperationType,
		arg.ClientID,
		arg.Status,
	)
	var i SyncOperation
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.FileID,
		&i.OperationType,
		&i.ClientID,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, password_hash, tier)
VALUES ($1, $2, $3)
RETURNING id, email, password_hash, tier, storage_used_bytes, created_at, updated_at
`

type CreateUserParams struct {
	Email        string
	PasswordHash string
	Tier         UserTier
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Email, arg.PasswordHash, arg.Tier)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Tier,
		&i.StorageUsedBytes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createWorkspace = `-- name: CreateWorkspace :one
INSERT INTO workspaces (user_id, name, storage_limit_bytes)
VALUES ($1, $2, $3)
RETURNING id, user_id, name, storage_limit_bytes, storage_used_bytes, created_at, updated_at
`

type CreateWorkspaceParams struct {
	UserID            pgtype.UUID
	Name              string
	StorageLimitBytes int64
}

func (q *Queries) CreateWorkspace(ctx context.Context, arg CreateWorkspaceParams) (Workspace, error) {
	row := q.db.QueryRow(ctx, createWorkspace, arg.UserID, arg.Name, arg.StorageLimitBytes)
	var i Workspace
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.StorageLimitBytes,
		&i.StorageUsedBytes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAPIToken = `-- name: DeleteAPIToken :exec
DELETE FROM api_tokens WHERE id = $1 AND user_id = $2
`

type DeleteAPITokenParams struct {
	ID     pgtype.UUID
	UserID pgtype.UUID
}

func (q *Queries) DeleteAPIToken(ctx context.Context, arg DeleteAPITokenParams) error {
	_, err := q.db.Exec(ctx, deleteAPIToken, arg.ID, arg.UserID)
	return err
}

const deleteFile = `-- name: DeleteFile :exec
DELETE FROM files WHERE workspace_id = $1 AND file_path = $2
`

type DeleteFileParams struct {
	WorkspaceID pgtype.UUID
	FilePath    string
}

func (q *Queries) DeleteFile(ctx context.Context, arg DeleteFileParams) error {
	_, err := q.db.Exec(ctx, deleteFile, arg.WorkspaceID, arg.FilePath)
	return err
}

const getFile = `-- name: GetFile :one
SELECT id, workspace_id, file_path, content_hash, content, size_bytes, mime_type, last_modified, created_at, updated_at FROM files WHERE workspace_id = $1 AND file_path = $2
`

type GetFileParams struct {
	WorkspaceID pgtype.UUID
	FilePath    string
}

func (q *Queries) GetFile(ctx context.Context, arg GetFileParams) (File, error) {
	row := q.db.QueryRow(ctx, getFile, arg.WorkspaceID, arg.FilePath)
	var i File
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.FilePath,
		&i.ContentHash,
		&i.Content,
		&i.SizeBytes,
		&i.MimeType,
		&i.LastModified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFileByID = `-- name: GetFileByID :one
SELECT id, workspace_id, file_path, content_hash, content, size_bytes, mime_type, last_modified, created_at, updated_at FROM files WHERE id = $1
`

func (q *Queries) GetFileByID(ctx context.Context, id pgtype.UUID) (File, error) {
	row := q.db.QueryRow(ctx, getFileByID, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.FilePath,
		&i.ContentHash,
		&i.Content,
		&i.SizeBytes,
		&i.MimeType,
		&i.LastModified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFileContent = `-- name: GetFileContent :one
SELECT content FROM files WHERE workspace_id = $1 AND file_path = $2
`

type GetFileContentParams struct {
	WorkspaceID pgtype.UUID
	FilePath    string
}

func (q *Queries) GetFileContent(ctx context.Context, arg GetFileContentParams) ([]byte, error) {
	row := q.db.QueryRow(ctx, getFileContent, arg.WorkspaceID, arg.FilePath)
	var content []byte
	err := row.Scan(&content)
	return content, err
}

const getFileMetadata = `-- name: GetFileMetadata :one
SELECT file_id, format, parsed_blocks, properties, word_count, last_parsed FROM file_metadata WHERE file_id = $1
`

func (q *Queries) GetFileMetadata(ctx context.Context, fileID pgtype.UUID) (FileMetadatum, error) {
	row := q.db.QueryRow(ctx, getFileMetadata, fileID)
	var i FileMetadatum
	err := row.Scan(
		&i.FileID,
		&i.Format,
		&i.ParsedBlocks,
		&i.Properties,
		&i.WordCount,
		&i.LastParsed,
	)
	return i, err
}

const getFileVersions = `-- name: GetFileVersions :many
SELECT id, file_id, version_number, content_hash, content, created_at FROM file_versions 
WHERE file_id = $1 
ORDER BY version_number DESC 
LIMIT $2
`

type GetFileVersionsParams struct {
	FileID pgtype.UUID
	Limit  int32
}

func (q *Queries) GetFileVersions(ctx context.Context, arg GetFileVersionsParams) ([]FileVersion, error) {
	rows, err := q.db.Query(ctx, getFileVersions, arg.FileID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FileVersion
	for rows.Next() {
		var i FileVersion
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.VersionNumber,
			&i.ContentHash,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSyncOperations = `-- name: GetSyncOperations :many
SELECT id, workspace_id, file_id, operation_type, client_id, status, error_message, created_at FROM sync_operations 
WHERE workspace_id = $1 
ORDER BY created_at DESC 
LIMIT $2
`

type GetSyncOperationsParams struct {
	WorkspaceID pgtype.UUID
	Limit       int32
}

func (q *Queries) GetSyncOperations(ctx context.Context, arg GetSyncOperationsParams) ([]SyncOperation, error) {
	rows, err := q.db.Query(ctx, getSyncOperations, arg.WorkspaceID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SyncOperation
	for rows.Next() {
		var i SyncOperation
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FileID,
			&i.OperationType,
			&i.ClientID,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokenByHash = `-- name: GetTokenByHash :one
SELECT t.id, t.user_id, t.token_hash, t.name, t.last_used_at, t.expires_at, t.created_at, u.id as user_id, u.email, u.tier 
FROM api_tokens t
JOIN users u ON t.user_id = u.id
WHERE t.token_hash = $1 AND (t.expires_at IS NULL OR t.expires_at > NOW())
`

type GetTokenByHashRow struct {
	ID         pgtype.UUID
	UserID     pgtype.UUID
	TokenHash  string
	Name       string
	LastUsedAt pgtype.Timestamptz
	ExpiresAt  pgtype.Timestamptz
	CreatedAt  pgtype.Timestamptz
	UserID_2   pgtype.UUID
	Email      string
	Tier       UserTier
}

func (q *Queries) GetTokenByHash(ctx context.Context, tokenHash string) (GetTokenByHashRow, error) {
	row := q.db.QueryRow(ctx, getTokenByHash, tokenHash)
	var i GetTokenByHashRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.Name,
		&i.LastUsedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UserID_2,
		&i.Email,
		&i.Tier,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, tier, storage_used_bytes, created_at, updated_at FROM users WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Tier,
		&i.StorageUsedBytes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, password_hash, tier, storage_used_bytes, created_at, updated_at FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Tier,
		&i.StorageUsedBytes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWorkspaceByID = `-- name: GetWorkspaceByID :one
SELECT id, user_id, name, storage_limit_bytes, storage_used_bytes, created_at, updated_at FROM workspaces WHERE id = $1
`

func (q *Queries) GetWorkspaceByID(ctx context.Context, id pgtype.UUID) (Workspace, error) {
	row := q.db.QueryRow(ctx, getWorkspaceByID, id)
	var i Workspace
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.StorageLimitBytes,
		&i.StorageUsedBytes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWorkspaceStorageUsage = `-- name: GetWorkspaceStorageUsage :one
SELECT 
    w.storage_limit_bytes,
    w.storage_used_bytes,
    COUNT(f.id) as file_count,
    COALESCE(SUM(f.size_bytes), 0) as actual_storage_used
FROM workspaces w
LEFT JOIN files f ON w.id = f.workspace_id
WHERE w.id = $1
GROUP BY w.id, w.storage_limit_bytes, w.storage_used_bytes
`

type GetWorkspaceStorageUsageRow struct {
	StorageLimitBytes int64
	StorageUsedBytes  pgtype.Int8
	FileCount         int64
	ActualStorageUsed interface{}
}

func (q *Queries) GetWorkspaceStorageUsage(ctx context.Context, id pgtype.UUID) (GetWorkspaceStorageUsageRow, error) {
	row := q.db.QueryRow(ctx, getWorkspaceStorageUsage, id)
	var i GetWorkspaceStorageUsageRow
	err := row.Scan(
		&i.StorageLimitBytes,
		&i.StorageUsedBytes,
		&i.FileCount,
		&i.ActualStorageUsed,
	)
	return i, err
}

const getWorkspacesByUser = `-- name: GetWorkspacesByUser :many
SELECT id, user_id, name, storage_limit_bytes, storage_used_bytes, created_at, updated_at FROM workspaces WHERE user_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetWorkspacesByUser(ctx context.Context, userID pgtype.UUID) ([]Workspace, error) {
	rows, err := q.db.Query(ctx, getWorkspacesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Workspace
	for rows.Next() {
		var i Workspace
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.StorageLimitBytes,
			&i.StorageUsedBytes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFiles = `-- name: ListFiles :many
SELECT id, workspace_id, file_path, content_hash, size_bytes, mime_type, last_modified, updated_at
FROM files 
WHERE workspace_id = $1 
ORDER BY file_path
`

type ListFilesRow struct {
	ID           pgtype.UUID
	WorkspaceID  pgtype.UUID
	FilePath     string
	ContentHash  string
	SizeBytes    int64
	MimeType     pgtype.Text
	LastModified pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
}

func (q *Queries) ListFiles(ctx context.Context, workspaceID pgtype.UUID) ([]ListFilesRow, error) {
	rows, err := q.db.Query(ctx, listFiles, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFilesRow
	for rows.Next() {
		var i ListFilesRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FilePath,
			&i.ContentHash,
			&i.SizeBytes,
			&i.MimeType,
			&i.LastModified,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSyncOperationStatus = `-- name: UpdateSyncOperationStatus :exec
UPDATE sync_operations 
SET status = $2, error_message = $3 
WHERE id = $1
`

type UpdateSyncOperationStatusParams struct {
	ID           pgtype.UUID
	Status       string
	ErrorMessage pgtype.Text
}

func (q *Queries) UpdateSyncOperationStatus(ctx context.Context, arg UpdateSyncOperationStatusParams) error {
	_, err := q.db.Exec(ctx, updateSyncOperationStatus, arg.ID, arg.Status, arg.ErrorMessage)
	return err
}

const updateTokenLastUsed = `-- name: UpdateTokenLastUsed :exec
UPDATE api_tokens SET last_used_at = NOW() WHERE id = $1
`

func (q *Queries) UpdateTokenLastUsed(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateTokenLastUsed, id)
	return err
}

const updateUserStorageUsed = `-- name: UpdateUserStorageUsed :exec
UPDATE users SET storage_used_bytes = $2, updated_at = NOW() WHERE id = $1
`

type UpdateUserStorageUsedParams struct {
	ID               pgtype.UUID
	StorageUsedBytes pgtype.Int8
}

func (q *Queries) UpdateUserStorageUsed(ctx context.Context, arg UpdateUserStorageUsedParams) error {
	_, err := q.db.Exec(ctx, updateUserStorageUsed, arg.ID, arg.StorageUsedBytes)
	return err
}

const updateWorkspaceStorageUsed = `-- name: UpdateWorkspaceStorageUsed :exec
UPDATE workspaces SET storage_used_bytes = $2, updated_at = NOW() WHERE id = $1
`

type UpdateWorkspaceStorageUsedParams struct {
	ID               pgtype.UUID
	StorageUsedBytes pgtype.Int8
}

func (q *Queries) UpdateWorkspaceStorageUsed(ctx context.Context, arg UpdateWorkspaceStorageUsedParams) error {
	_, err := q.db.Exec(ctx, updateWorkspaceStorageUsed, arg.ID, arg.StorageUsedBytes)
	return err
}

const upsertFile = `-- name: UpsertFile :one
INSERT INTO files (workspace_id, file_path, content_hash, content, size_bytes, mime_type, last_modified)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (workspace_id, file_path) 
DO UPDATE SET 
    content_hash = EXCLUDED.content_hash,
    content = EXCLUDED.content,
    size_bytes = EXCLUDED.size_bytes,
    mime_type = EXCLUDED.mime_type,
    last_modified = EXCLUDED.last_modified,
    updated_at = NOW()
RETURNING id, workspace_id, file_path, content_hash, content, size_bytes, mime_type, last_modified, created_at, updated_at
`

type UpsertFileParams struct {
	WorkspaceID  pgtype.UUID
	FilePath     string
	ContentHash  string
	Content      []byte
	SizeBytes    int64
	MimeType     pgtype.Text
	LastModified pgtype.Timestamptz
}

func (q *Queries) UpsertFile(ctx context.Context, arg UpsertFileParams) (File, error) {
	row := q.db.QueryRow(ctx, upsertFile,
		arg.WorkspaceID,
		arg.FilePath,
		arg.ContentHash,
		arg.Content,
		arg.SizeBytes,
		arg.MimeType,
		arg.LastModified,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.FilePath,
		&i.ContentHash,
		&i.Content,
		&i.SizeBytes,
		&i.MimeType,
		&i.LastModified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertFileMetadata = `-- name: UpsertFileMetadata :exec
INSERT INTO file_metadata (file_id, format, parsed_blocks, properties, word_count)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (file_id) 
DO UPDATE SET 
    format = EXCLUDED.format,
    parsed_blocks = EXCLUDED.parsed_blocks,
    properties = EXCLUDED.properties,
    word_count = EXCLUDED.word_count,
    last_parsed = NOW()
`

type UpsertFileMetadataParams struct {
	FileID       pgtype.UUID
	Format       string
	ParsedBlocks []byte
	Properties   []byte
	WordCount    pgtype.Int4
}

func (q *Queries) UpsertFileMetadata(ctx context.Context, arg UpsertFileMetadataParams) error {
	_, err := q.db.Exec(ctx, upsertFileMetadata,
		arg.FileID,
		arg.Format,
		arg.ParsedBlocks,
		arg.Properties,
		arg.WordCount,
	)
	return err
}
